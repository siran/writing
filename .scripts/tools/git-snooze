#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
git-snooze v1.0.0 (Python)

PURPOSE
  Time-based deferral of local Git changes with automatic reappearance.
  Built to avoid the "forgotten stash" problem: snoozed work resurfaces.

CORE IDEAS
  - Tracked files: hidden via `git update-index --skip-worktree`.
  - Untracked files: renamed to `*.Nd.snoozed.*` and ignored by .gitignore.
  - Local-only state stored in `.git/snooze.db`.
  - A pre-commit hook runs `git snooze sweep` to auto-unsnooze due items.
  - If sweep unsnoozes anything, it prints a visible warning to stdout.

COMMANDS
  git snooze <path> [days]              default days=4
  git snooze --force <path> [days]      allow snoozing the tool itself
  git snooze all [days]
  git snooze -l | list
  git snooze sweep
  git snooze unsnooze <path>|all
  git snooze -u <path>|all              alias for unsnooze
  git snooze doctor [--repair]

INSTALL (for curl/wget workflows)
  python3 git-snooze install --global
  python3 git-snooze install --repo

  --global installs to ~/.local/bin/git-snooze and sets global git aliases.
  --repo installs to .scripts/tools/git-snooze inside the current repo and
  installs the repo pre-commit hook + .gitignore rule.

SAFETY
  - Refuse snoozing the snooze tool itself unless --force is passed.
  - `snooze all` never snoozes the tool or its common backups.

COMPATIBILITY
  - Python 3.6+ (no match/case; conservative stdlib only)
"""

from __future__ import print_function

import os
import re
import sys
import time
import stat
import shutil
import subprocess
import urllib.request

DB_REL = os.path.join(".git", "snooze.db")
DEFAULT_DAYS = 4
REPAIR_YEARS_DAYS = 365 * 100


# ---------------------------
# Utilities
# ---------------------------

def die(msg, code=1):
    print("git-snooze: " + msg, file=sys.stderr)
    raise SystemExit(code)

def now_epoch():
    return int(time.time())

def run_git(args, cwd=None, capture=False, check=True):
    cmd = ["git"] + list(args)
    if capture:
        p = subprocess.Popen(cmd, cwd=cwd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = p.communicate()
        out = out.decode("utf-8", "replace")
        err = err.decode("utf-8", "replace")
        if check and p.returncode != 0:
            die("git command failed: {}\n{}".format(" ".join(cmd), err.strip()))
        return out
    p = subprocess.Popen(cmd, cwd=cwd)
    rc = p.wait()
    if check and rc != 0:
        die("git command failed: {}".format(" ".join(cmd)))
    return ""

def is_git_repo():
    try:
        out = run_git(["rev-parse", "--is-inside-work-tree"], capture=True, check=True).strip()
        return out == "true"
    except SystemExit:
        return False

def repo_root():
    out = run_git(["rev-parse", "--show-toplevel"], capture=True).strip()
    if not out:
        die("not a git repo")
    return out

def abs_path(root, relpath):
    return os.path.normpath(os.path.join(root, relpath))

def ensure_db(root):
    db = abs_path(root, DB_REL)
    d = os.path.dirname(db)
    if not os.path.isdir(d):
        os.makedirs(d)
    if not os.path.exists(db):
        with open(db, "a"):
            pass
    return db

def make_executable(path):
    st = os.stat(path)
    os.chmod(path, st.st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

def grep_file(path, pattern):
    rx = re.compile(pattern)
    try:
        with open(path, "r") as f:
            for line in f:
                if rx.search(line):
                    return True
    except IOError:
        return False
    return False

def warn_setup_once(root):
    ig = os.path.join(root, ".gitignore")
    hook = os.path.join(root, ".git", "hooks", "pre-commit")

    if (not os.path.isfile(ig)) or (not grep_file(ig, r'^\*\.snoozed\.\*$')):
        print("git-snooze: note: add to .gitignore: *.snoozed.*", file=sys.stderr)

    if (not os.path.isfile(hook)) or (not grep_file(hook, r'git-snooze sweep')):
        print("git-snooze: note: pre-commit hook missing/incorrect (auto-wake off)", file=sys.stderr)

def is_tracked(path):
    rc = subprocess.call(["git", "ls-files", "--error-unmatch", "--", path],
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    return rc == 0

def set_skip_worktree(path):
    subprocess.check_call(["git", "update-index", "--skip-worktree", "--", path])

def unset_skip_worktree(path):
    subprocess.call(["git", "update-index", "--no-skip-worktree", "--", path],
                    stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

def is_self_path(path):
    return (path == ".scripts/tools/git-snooze") or path.startswith(".scripts/tools/git-snooze.")

def should_skip_in_all(path):
    return is_self_path(path)


# ---------------------------
# Rename-mode naming
# ---------------------------

def snoozed_name(days, relpath):
    d = os.path.dirname(relpath)
    f = os.path.basename(relpath)

    # dotfile with no extra dots => no extension
    if f.startswith(".") and f.count(".") == 1:
        out = f + ".{}d.snoozed".format(days)
        return os.path.join(d, out) if d else out

    if "." in f and not f.startswith("."):
        base, ext = f.rsplit(".", 1)
        out = "{}.{}d.snoozed.{}".format(base, days, ext)
    else:
        out = f + ".{}d.snoozed".format(days)

    return os.path.join(d, out) if d else out

def unsnoozed_name_from_snoozed(relpath):
    return re.sub(r"\.[0-9]+d\.snoozed(\.|$)", r"\1", relpath)


# ---------------------------
# DB ops
# ---------------------------

def db_read(db_path_):
    rows = []
    try:
        with open(db_path_, "r") as f:
            for line in f:
                line = line.rstrip("\n")
                if not line:
                    continue
                parts = line.split("\t")
                if len(parts) < 5:
                    continue
                rows.append(parts[:5])
    except IOError:
        pass
    return rows

def db_write(db_path_, rows):
    tmp = db_path_ + ".tmp"
    with open(tmp, "w") as f:
        for r in rows:
            f.write("\t".join([str(x) for x in r]) + "\n")
    os.replace(tmp, db_path_)

def db_delete_orig(db_path_, orig):
    rows = db_read(db_path_)
    rows2 = []
    for r in rows:
        if len(r) >= 3 and r[2] == orig:
            continue
        rows2.append(r)
    db_write(db_path_, rows2)

def db_lookup_by_orig(db_path_, orig):
    for r in db_read(db_path_):
        if len(r) >= 3 and r[2] == orig:
            return r
    return None

def db_add_index(db_path_, orig, start_epoch, days):
    rows = db_read(db_path_)
    rows.append(["index", "-", orig, str(start_epoch), str(days)])
    db_write(db_path_, rows)

def db_add_rename(db_path_, snoozed, orig, start_epoch, days):
    rows = db_read(db_path_)
    rows.append(["rename", snoozed, orig, str(start_epoch), str(days)])
    db_write(db_path_, rows)


# ---------------------------
# Commands
# ---------------------------

def cmd_list(root, db_path_):
    now = now_epoch()
    items = []
    for mode, snoozed, orig, start, days in db_read(db_path_):
        try:
            start_i = int(start)
            days_i = int(days)
        except Exception:
            continue
        due = start_i + days_i * 86400
        rem = due - now
        if rem <= 0:
            rdays = 0
        else:
            rdays = int((rem + 86399) // 86400)
        items.append((rdays, mode, orig, snoozed))

    items.sort(key=lambda x: (x[0], x[2]))

    if not items:
        print("SNOOZED FILES: (none)")
        return

    print("SNOOZED FILES (by days remaining):")
    cur = None
    for rdays, mode, orig, snoozed in items:
        if cur != rdays:
            cur = rdays
            print("\n{} day{}:".format(cur, "" if cur == 1 else "s"))
        if mode == "index":
            print("  - {}  [tracked: skip-worktree]".format(orig))
        else:
            print("  - {}  <=  {}  [untracked: rename]".format(orig, snoozed))

def cmd_sweep(root, db_path_):
    now = now_epoch()
    keep = []
    unsnoozed_any = False

    for mode, snoozed, orig, start, days in db_read(db_path_):
        try:
            start_i = int(start)
            days_i = int(days)
        except Exception:
            continue

        due = start_i + days_i * 86400
        if now < due:
            keep.append([mode, snoozed, orig, start, days])
            continue

        unsnoozed_any = True
        if mode == "index":
            if os.path.exists(os.path.join(root, orig)):
                unset_skip_worktree(orig)
            print("UNSNOOZED(index): {}".format(orig))
        else:
            sp = os.path.join(root, snoozed)
            op = os.path.join(root, orig)
            if os.path.exists(sp) and (not os.path.exists(op)):
                os.rename(sp, op)
            print("UNSNOOZED(rename): {}".format(orig))

    db_write(db_path_, keep)

    if unsnoozed_any:
        print("")
        print("⚠ git-snooze: one or more files were automatically unsnoozed")
        print("⚠ review changes before completing this commit")
        print("")

def cmd_unsnooze_one(root, db_path_, target):
    if not target:
        die("usage: git snooze -u <path>|all")

    # Accept orig-path or snoozed-path
    orig = target

    if is_tracked(orig):
        unset_skip_worktree(orig)

    rec = db_lookup_by_orig(db_path_, orig)
    if rec is None:
        if ".snoozed" in target:
            snoozed = target
            orig2 = unsnoozed_name_from_snoozed(target)
            sp = os.path.join(root, snoozed)
            op = os.path.join(root, orig2)
            if os.path.exists(sp) and (not os.path.exists(op)):
                os.rename(sp, op)
            db_delete_orig(db_path_, orig2)
            print("UNSNOOZED: {}".format(orig2))
            return
        print("UNSNOOZED(index): {} (no db record)".format(orig))
        return

    mode, snoozed, orig_db, start, days = rec
    if mode == "rename":
        sp = os.path.join(root, snoozed)
        op = os.path.join(root, orig_db)
        if os.path.exists(sp) and (not os.path.exists(op)):
            os.rename(sp, op)

    db_delete_orig(db_path_, orig_db)
    print("UNSNOOZED: {}".format(orig_db))

def cmd_unsnooze_all(root, db_path_):
    for mode, snoozed, orig, start, days in db_read(db_path_):
        if mode == "index":
            if os.path.exists(os.path.join(root, orig)):
                unset_skip_worktree(orig)
            print("UNSNOOZED(index): {}".format(orig))
        else:
            sp = os.path.join(root, snoozed)
            op = os.path.join(root, orig)
            if os.path.exists(sp) and (not os.path.exists(op)):
                os.rename(sp, op)
            print("UNSNOOZED(rename): {}".format(orig))
    db_write(db_path_, [])

def cmd_snooze_one(root, db_path_, path, days, force=False):
    if not path:
        die("usage: git snooze <path> [days]")
    if days is None:
        days = DEFAULT_DAYS
    try:
        days_i = int(days)
    except Exception:
        die("days must be a number")

    if is_self_path(path) and (not force):
        die('refusing to snooze the snooze tool itself. Use: git snooze --force "{}" [days]'.format(path))

    start = now_epoch()
    db_delete_orig(db_path_, path)

    ap = os.path.join(root, path)
    if not os.path.exists(ap):
        die("file not found: {}".format(path))

    if is_tracked(path):
        set_skip_worktree(path)
        db_add_index(db_path_, path, start, days_i)
        print("SNOOZED(index): {} ({}d)".format(path, days_i))
        return

    snoozed = snoozed_name(days_i, path)
    sp = os.path.join(root, snoozed)
    if os.path.exists(sp):
        die("target exists: {}".format(snoozed))
    os.rename(ap, sp)
    db_add_rename(db_path_, snoozed, path, start, days_i)
    print("SNOOZED(rename): {} -> {} ({}d)".format(path, snoozed, days_i))

def cmd_snooze_all(root, db_path_, days):
    if days is None:
        days = DEFAULT_DAYS
    try:
        days_i = int(days)
    except Exception:
        die("days must be a number")

    start = now_epoch()
    print("SNOOZING ALL local changes ({}d)".format(days_i))

    tracked = run_git(["diff", "--name-only"], capture=True).splitlines()
    for f in tracked:
        f = f.strip()
        if not f:
            continue
        db_delete_orig(db_path_, f)
        set_skip_worktree(f)
        db_add_index(db_path_, f, start, days_i)
        print("  tracked: {}".format(f))

    untracked = run_git(["ls-files", "--others", "--exclude-standard"], capture=True).splitlines()
    for f in untracked:
        f = f.strip()
        if not f:
            continue
        if should_skip_in_all(f):
            print("  skip (self): {}".format(f))
            continue

        ap = os.path.join(root, f)
        if not os.path.exists(ap):
            continue

        db_delete_orig(db_path_, f)
        snoozed = snoozed_name(days_i, f)
        sp = os.path.join(root, snoozed)
        if os.path.exists(sp):
            die("target exists: {}".format(snoozed))
        os.rename(ap, sp)
        db_add_rename(db_path_, snoozed, f, start, days_i)
        print("  untracked: {} -> {}".format(f, snoozed))

def skip_worktree_files():
    out = run_git(["ls-files", "-v"], capture=True)
    files = []
    for line in out.splitlines():
        if line.startswith("S "):
            files.append(line[2:].strip())
    return files

def cmd_doctor(root, db_path_):
    print("git-snooze doctor")
    print("  repo: {}".format(root))

    ig = os.path.join(root, ".gitignore")
    hook = os.path.join(root, ".git", "hooks", "pre-commit")

    if os.path.isfile(ig) and grep_file(ig, r'^\*\.snoozed\.\*$'):
        print("  .gitignore: OK")
    else:
        print("  .gitignore: missing *.snoozed.*")

    if os.path.isfile(hook) and grep_file(hook, r'git-snooze sweep'):
        print("  hook: OK")
    else:
        print("  hook: missing/incorrect")

    if os.path.isfile(db_path_):
        print("  db: OK")
    else:
        print("  db: will be created on first use")

def cmd_doctor_repair(root, db_path_):
    print("git-snooze doctor --repair")
    print("  scanning index for skip-worktree files...")

    start = now_epoch()
    repaired = 0

    for f in skip_worktree_files():
        if not f:
            continue
        if db_lookup_by_orig(db_path_, f) is None:
            db_add_index(db_path_, f, start, REPAIR_YEARS_DAYS)
            print("  repaired: added db record for {} (duration={}d)".format(f, REPAIR_YEARS_DAYS))
            repaired += 1

    if repaired == 0:
        print("  nothing to repair.")
    else:
        print("  repaired {} file(s).".format(repaired))
        print('  tip: set a real timer by re-snoozing: git snooze "<path>" 4')


# ---------------------------
# Install command
# ---------------------------

def ensure_line_in_file(path, line):
    try:
        content = ""
        if os.path.exists(path):
            with open(path, "r") as f:
                content = f.read()
        if line.strip() in content.splitlines():
            return False
        with open(path, "a") as f:
            if content and not content.endswith("\n"):
                f.write("\n")
            f.write(line.rstrip("\n") + "\n")
        return True
    except IOError as e:
        die("cannot edit {}: {}".format(path, e))

def write_file(path, text):
    d = os.path.dirname(path)
    if d and not os.path.isdir(d):
        os.makedirs(d)
    with open(path, "w") as f:
        f.write(text)

def install_repo(root, source_bytes):
    target = os.path.join(root, ".scripts", "tools", "git-snooze")
    write_file(target, source_bytes.decode("utf-8", "replace"))
    make_executable(target)

    # .gitignore rule
    ensure_line_in_file(os.path.join(root, ".gitignore"), "*.snoozed.*")

    # pre-commit hook
    hook = os.path.join(root, ".git", "hooks", "pre-commit")
    hook_text = "#!/bin/sh\n.scripts/tools/git-snooze sweep  || true\n"
    write_file(hook, hook_text)
    make_executable(hook)

    print("installed: {}".format(target))
    print("installed: {}".format(hook))
    print("updated:   {}".format(os.path.join(root, ".gitignore")))
    print("")
    print("next:")
    print("  git config --global alias.snooze '!.scripts/tools/git-snooze'")
    print("  git config --global alias.snooze-list '!.scripts/tools/git-snooze list'")

def install_global(source_bytes):
    home = os.path.expanduser("~")
    target_dir = os.path.join(home, ".local", "bin")
    target = os.path.join(target_dir, "git-snooze")

    if not os.path.isdir(target_dir):
        os.makedirs(target_dir)

    write_file(target, source_bytes.decode("utf-8", "replace"))
    make_executable(target)

    # global aliases pointing to git-snooze executable in PATH
    # (user must have ~/.local/bin in PATH)
    subprocess.call(["git", "config", "--global", "alias.snooze", "!git-snooze"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    subprocess.call(["git", "config", "--global", "alias.snooze-list", "!git-snooze list"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    print("installed: {}".format(target))
    print("updated:   global git aliases (alias.snooze, alias.snooze-list)")
    print("")
    print("ensure PATH contains ~/.local/bin, e.g.:")
    print('  export PATH="$HOME/.local/bin:$PATH"')

def cmd_install(argv0_path, args):
    # Source can be:
    #  - the running script file (default)
    #  - a URL
    #  - a local path
    src = args.source
    if src:
        if re.match(r"^https?://", src):
            with urllib.request.urlopen(src) as r:
                source_bytes = r.read()
        else:
            with open(src, "rb") as f:
                source_bytes = f.read()
    else:
        # read current script file
        with open(argv0_path, "rb") as f:
            source_bytes = f.read()

    if args.global_install:
        install_global(source_bytes)
        return

    # repo install (default if --repo)
    if not is_git_repo():
        die("install --repo requires running inside a git repo")
    root = repo_root()
    install_repo(root, source_bytes)


# ---------------------------
# Dispatch
# ---------------------------

def usage():
    print("""git snooze: hide files for N days

USAGE
  git snooze <path> [days]
  git snooze --force <path> [days]
  git snooze all [days]
  git snooze -l | list
  git snooze sweep
  git snooze unsnooze <path> | all
  git snooze -u <path> | all
  git snooze doctor [--repair]

INSTALL
  python3 git-snooze install --global [--source URL|PATH]
  python3 git-snooze install --repo   [--source URL|PATH]

SETUP (repo install)
  .gitignore: *.snoozed.*
  pre-commit: .scripts/tools/git-snooze sweep || true
""")

def main(argv):
    # Allow running as: python3 script install ...
    if len(argv) >= 2 and argv[1] == "install":
        # parse install args (keep it minimal; no fancy features)
        parser = argparse_install()
        args = parser.parse_args(argv[2:])
        cmd_install(argv[0], args)
        return 0

    # Normal git-snooze behavior
    if not is_git_repo():
        die("not a git repo")

    root = repo_root()
    db = ensure_db(root)

    if len(argv) >= 2 and argv[1] in ("-h", "--help", "help"):
        usage()
        return 0
    if len(argv) >= 2 and argv[1] in ("-l", "--list", "list"):
        cmd_list(root, db)
        return 0

    if len(argv) < 2:
        die("usage: git snooze <path> [days] | all [days] | -l | sweep | -u <path>|all | doctor [--repair]")

    cmd = argv[1]

    # -u / --unsnooze (flag form)
    if cmd in ("-u", "--unsnooze"):
        target = argv[2] if len(argv) >= 3 else None
        if target == "all":
            cmd_unsnooze_all(root, db)
        else:
            cmd_unsnooze_one(root, db, target)
        return 0

    # subcommand form
    if cmd == "unsnooze":
        target = argv[2] if len(argv) >= 3 else None
        if target == "all":
            cmd_unsnooze_all(root, db)
        else:
            cmd_unsnooze_one(root, db, target)
        return 0

    if cmd == "sweep":
        cmd_sweep(root, db)
        return 0

    if cmd == "doctor":
        if len(argv) >= 3 and argv[2] == "--repair":
            cmd_doctor_repair(root, db)
        else:
            cmd_doctor(root, db)
        return 0

    if cmd == "all":
        days = argv[2] if len(argv) >= 3 else None
        cmd_snooze_all(root, db, days)
        warn_setup_once(root)
        print("")
        cmd_list(root, db)
        return 0

    if cmd in ("--force", "-f"):
        path = argv[2] if len(argv) >= 3 else None
        days = argv[3] if len(argv) >= 4 else None
        cmd_snooze_one(root, db, path, days, force=True)
        warn_setup_once(root)
        print("")
        cmd_list(root, db)
        return 0

    # Default: cmd is a path, optional days in argv[2]
    path = cmd
    days = argv[2] if len(argv) >= 3 else None
    cmd_snooze_one(root, db, path, days, force=False)
    warn_setup_once(root)
    print("")
    cmd_list(root, db)
    return 0

def argparse_install():
    # Minimal parser, compatible with older python3
    import argparse
    p = argparse.ArgumentParser(prog="git-snooze install", add_help=True)
    g = p.add_mutually_exclusive_group(required=True)
    g.add_argument("--global", dest="global_install", action="store_true", help="install to ~/.local/bin and set global git aliases")
    g.add_argument("--repo", dest="repo_install", action="store_true", help="install to current repo and install hook/.gitignore")
    p.add_argument("--source", default=None, help="URL or local path to install from (defaults to the running script)")
    return p


if __name__ == "__main__":
    try:
        sys.exit(main(sys.argv))
    except KeyboardInterrupt:
        die("interrupted", code=130)
